#!/usr/bin/perl

# Copyright (c) 2014 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use warnings;
use strict;

# Selection of outputs for spending:
#
# using %walletcmds use listunspent to find unspent outputs, which then get
# filered based on @txblacklist and $opt_a.
#
#
# Generation of new outputs:
#  total - txfee - abs = amount available for percentage breakdown
#
#  This means there can be four scenarios:
#
#  1) spending an absolute amount involves $abs > 0 and $pct = 100% for change
#
#  2) spending all via absolute, no change, $abs + $txfee = $total, $pct = 0.0
#
#  3) spending percentage only involves $abs = 0
#
#  4) spending percentage + absolute involves $pct adds to 100% and gets what is left
#     after $abs

sub usage
{
	printf STDERR "must define -x <command> to access the wallet\n";
	printf STDERR "must define -o <addr>:pct[,addr:pct] to send funds\n";
	exit(1);
}


use JSON;

use OpenBSD::Getopt;

our $opt_a;		# address (limit spending to inputs using this addr)
our $opt_b;		# blacklist of txhash to not use, comma separated
our $opt_c;		# conf file
our $opt_n;		# do not send tx if defined($opt_n)
our $opt_o;		# output addr:pct, comma separated
our $opt_t = 0.0001;	# txfee
our $opt_v = 0;		# verbosity
our $opt_C = 1;		# confirmation threshold, set to 0 for unconfirmed

our %walletcmds;

$opt_c = $ENV{'HOME'}."/.spendbtc.conf";

getopts('C:a:b:c:no:t:x:v');

our @txblacklist;
if (defined($opt_b)) {
	@txblacklist = split(/,/,$opt_b);
}

our @outputs;
if (defined($opt_o)) {
	@outputs = split(/,/,$opt_o);
}

if ( -f $opt_c ) {
	if ($opt_v > 0) {
		print "Parsing ".$opt_c."\n";
	}
	eval `cat $opt_c`;
}

if (!@outputs) {
	usage();
}

# sanity check that it equals 100%, 1.0 = 1%
my $pct = 0.0;
my $abs = 0.0;
foreach my $o (@outputs) {
	my ($addr,$p) = split(/:/,$o);
	if ($p =~ /%/) {
		$p =~ s/%//;
		my $tmp = $pct + $p;
		if ($opt_v > 0) {
			printf "adding pct .. %0.4f + %0.4f = %0.4f\n", $pct, $p, $tmp;
		}
		$pct = $tmp;
	} else {
		my $tmp = $abs + $p;
		if ($opt_v > 0) {
			printf "adding abs .. %0.8f + %0.8f = %0.8f\n", $abs, $p, $tmp;
		}
		$abs = $tmp;
	}
}
my $pctstr = sprintf("0.8f",$pct);
my $pct100 = sprintf("0.8f",100.0);
if ($pctstr ne $pct100) {
	printf "Oops, percentage adds up to %0.8f(%s), try again..\n",$pct,$pct;
	usage();
}

my @txsend = ();
my $txcount = 0;
my $txvalue = 0.00000000;

my $cmd;
my $json = JSON->new->allow_nonref;
foreach my $key (keys %walletcmds) {
	$cmd = $walletcmds{$key};
	if ($opt_v > 0) {
		print " ".$key.": ".$cmd;
	}
	open(U,"${cmd} listunspent ${opt_C} 2>&1 |");
	my $line;
	my $text = "";
	while(<U>) {
		chomp($line = $_);
		$text .= $line;
	}
	close(U);
	if ($text =~ /^rpcCommand:/) {
		printf "    %s: Error: %s\n", $key, $text;
		next;
	}

	my $parsed;
	eval {
		$parsed = $json->decode( $text );
	};
	if ($@) {
		printf "%s: json->decode('%s') Error: %s\n", $key, $text, $@;
		next;
	}

	#print $json->pretty->encode( $parsed );

	if (ref($parsed) ne "ARRAY") {
		print "Error somewhere, parsed ref = ".ref($parsed)."\n";
		exit(1);
	}

	TX:
	foreach my $tx (@{$parsed}) {
		if (ref($tx) ne "HASH") {
			print "Error somewhere, parsed tx = ".ref($tx)."\n";
			exit(1);
		}
		if ($opt_v > 0) {
			printf "%s: tx#%s %0.8f BTC\n", $key, $tx->{'txid'}, $tx->{'amount'};
		}
		foreach my $txb (@txblacklist) {
			if ($txb eq $tx->{'txid'}) {
				if ($opt_v > 0) {
					printf "%s: tx#%s matched txblacklist, skipping\n",
					    $key, $tx->{'txid'};
				}
				next TX;
			}
		}
		if (defined($opt_a)) {
			if ($opt_a ne $tx->{'address'}) {
				if ($opt_v > 0) {
					printf "%s: %s\@tx#%s != %s, skipping\n",
					    $key, $tx->{'address'}, $tx->{'txid'}, $opt_a;
				}
				next TX;
			}
		}
		$txcount++;
		if ($opt_v > 0) {
			foreach my $var (sort keys %{$tx}) {
				printf "%02d: '%s' = '%s'\n", $txcount, $var, $tx->{$var};
			}
		}
		my $txs;
		$txs->{'txid'} = $tx->{'txid'};
		$txs->{'vout'} = $tx->{'vout'};
		push @txsend,$txs;
		$txvalue += $tx->{'amount'}+0.00000000;
	}
	print $key.": All unspent inputs total: ".$txvalue."\n";
	print $key.": Wallets balance: ".`${cmd} getbalance`."\n";
}

if ($txvalue == 0.0) {
	print "0 BTC to spend, feedme!\n";
	exit(1);
}
if ($txvalue <= $abs) {
	print "Can't overspend BTC, feedme!\n";
	exit(1);
}
if ( !(($txvalue - $opt_t) == $abs) && $pct != 100.0) {
	printf "Absolute spend with leftovers (%0.2f%%), percent must be 100%% for change!\n",$pct;
	exit(1);
}

#print "Pretty view of transactions to send:\n";
#print $json->pretty->encode( \@txsend );
print "Compact view of transactions to send:\n";
#print $json->encode( \@txsend )."\n";
my $str = "[";
foreach my $tx (@txsend) {
	$str .= "{";
	foreach my $v (sort keys %{$tx}) {
		if ($v eq "txid") {
			$str .= sprintf "\"txid\":\"%s\",",$tx->{$v};
			next;
		}
		$str .= sprintf "\"vout\":%d",$tx->{$v};
	}
	$str .= "},"
}
$str =~ s/,$//;
$str .= "]";
print $str."\n";

my $sendtx = $str;

my $addrs;
my $net = $txvalue - $opt_t;
my $sum = 0.00000000;
my $abssum = 0.00000000;
foreach my $o (@outputs) {
	my ($addr,$pct) = split(/:/,$o);
	my $amt;
	if (!($pct =~ /%/)) {
		$amt = $pct;
		$addrs->{$addr} = sprintf "%0.8f",$amt;
		$abssum += $amt;
	}
}
my $absnet = $net - $abssum;
foreach my $o (@outputs) {
	my ($addr,$pct) = split(/:/,$o);
	my $amt;
	if ($pct =~ /%/) {
		$pct =~ s/%//;

		$amt = $absnet*($pct/100);
		$addrs->{$addr} = sprintf "%0.8f",$amt;
		$sum += $amt;

	}
}

print "Compact view of dest addrs:\n";
#print $json->encode( $addrs )."\n";
$str = "{";
foreach my $v (sort keys %{$addrs}) {
	$str .= sprintf "\"%s\":%0.8f,",$v,$addrs->{$v};
}
$str =~ s/,$//;
$str .= "}";
print $str."\n";

my $sendaddrs = $str;

printf "Tx Fee: %0.8f\n",$txvalue-$sum-$abssum;

my $rawtxhex;
open(C,"${cmd} createrawtransaction '${sendtx}' '${sendaddrs}'|");
my $tmp = <C>;
close(C);
if (!defined($tmp)) {
	print "rawtxhex !defined, bailing\n";
	exit(1);
}
chomp($rawtxhex = $tmp);

my $lasthex = $rawtxhex;
my $line;
my $signedhex;
foreach my $key (keys %walletcmds) {
	$cmd = $walletcmds{$key};
	my $signedtx = "";
	open(S,"${cmd} signrawtransaction ${lasthex} 2>&1 |");
	while(<S>) {
		chomp($line = $_);
		$signedtx .= $line;
	#	print "S: ".$line."\n";
	}
	close(S);
	if ($signedtx =~ /^rpcCommand/) {
		printf "%s: signrawtransaction Error: %s\n", $key, $signedtx;
		decoderaw($cmd, $lasthex);
		next;
	}
	my $parsedsignedtx;
	eval {
		if ($opt_v > 0) {
			printf "json->decode('%s')...\n",$signedtx;
		}
		$parsedsignedtx = $json->decode( $signedtx );
	};
	if ($@) {
		printf "json->decode('%s') failed: %s\n",$signedtx,$@;
		decoderaw($cmd, $signedtx);
	} else {
		$signedhex = $parsedsignedtx->{'hex'};
		$lasthex = $signedhex;
	}

}

open(SEND,">>","sendtx.log");
print SEND "${cmd} sendrawtransaction ${signedhex}\n";
close(SEND);

if (!defined($opt_n)) {
	my $line;
	my $text = "";
	open(C,"${cmd} sendrawtransaction ${signedhex} 2>&1 |");
	while(<C>) {
		chomp($line = $_);
		$text .= $line;
	}
	close(C);
	if ($text =~ /^rpcCommand/) {
		printf "signrawtransaction Error: %s\n", $text;
		decoderaw($cmd, $signedhex);
		exit(1);
	}
	system("./pushtx ${signedhex}");
}

decoderaw($cmd,$signedhex);
close(D);

sub decoderaw {
	my ($cmd, $rawtx) = @_;
	open(D,"${cmd} decoderawtransaction ${rawtx}|");
	while(<D>) {
		print "D: ".$_;
	}
}
