#!/usr/bin/perl

# Copyright (c) 2014 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use warnings;
use strict;

# Selection of outputs for spending:
#
# using %walletcmds use listunspent to find unspent outputs, which then get
# filered based on @txblacklist and @txaddrs
#
#
# Generation of new outputs:
#  total - txfee - abs = amount available for percentage breakdown
#
#  This means there can be four scenarios:
#
#  1) spending an absolute amount involves $abs > 0 and $pct = 100% for change
#
#  2) spending all via absolute, no change, $abs + $txfee = $total, $pct = 0.0
#
#  3) spending percentage only involves $abs = 0
#
#  4) spending percentage + absolute involves $pct adds to 100% and gets what is left
#     after $abs

sub usage
{
	printf STDERR "must define -x <command> to access the wallet\n";
	printf STDERR "must define -o <addr>:pct[,addr:pct] to send funds\n";
	exit(1);
}


use JSON;

use OpenBSD::Getopt;

our $usdperbtc = 256.0; # random value, over-ride in config
our @txaddrs;		# addresses (limit spending to inputs using these addrs)
our $opt_b;		# blacklist of txhash to not use, comma separated
our $opt_c;		# conf file
our $opt_m;		# minimum amount to include
our $opt_n;		# do not send tx if defined($opt_n)
our $opt_o;		# output addr:pct, comma separated
our $opt_t = 0.0001;	# txfee
our $opt_v = 0;		# verbosity
our $opt_C = 1;		# confirmation threshold, set to 0 for unconfirmed

our %walletcmds;

$opt_c = $ENV{'HOME'}."/.spendbtc.conf";

getopts('C:a:b:c:m:no:t:x:v');

our @txblacklist;
if (defined($opt_b)) {
	@txblacklist = split(/,/,$opt_b);
}

our @outputs;
if (defined($opt_o)) {
	@outputs = split(/,/,$opt_o);
}

if ( -f $opt_c ) {
	if ($opt_v > 0) {
		print "Parsing ".$opt_c."\n";
	}
	eval `cat $opt_c`;
}

if (!@outputs) {
	usage();
}

# sanity check that it equals 100%, 1.0 = 1%
my $pct = 0.0;
my $abs = 0.0;
foreach my $o (@outputs) {
	my ($addr,$p,$min) = split(/:/,$o);
	if ($p =~ /%/) {
		$p =~ s/%//;
		my $tmp = $pct + $p;
		if ($opt_v > 0) {
			printf "adding pct .. %0.4f + %0.4f = %0.4f\n", $pct, $p, $tmp;
		}
		$pct = $tmp;
	} elsif ($p =~ /usd$/i) {
		$p =~ s/usd//i;
		my $btc = $p * (1/$usdperbtc);
		if ($opt_v > 0) {
			printf "adding usd .. %0.2f usd -> %0.8fi btc\n", $p, $btc;
		}
		$abs += $btc;
	} else {
		my $tmp = $abs + $p;
		if ($opt_v > 0) {
			printf "adding abs .. %0.8f + %0.8f = %0.8f\n", $abs, $p, $tmp;
		}
		$abs = $tmp;
	}
}
my $pctstr = sprintf("0.8f",$pct);
my $pct100 = sprintf("0.8f",100.0);
if ($pctstr ne $pct100) {
	printf "Oops, percentage adds up to %0.8f(%s), try again..\n",$pct,$pct;
	usage();
}

my @txsend = ();
my $txcount = 0;
my $txvalue = 0.00000000;

my $cmd;
my $json = JSON->new->allow_nonref;
foreach my $key (keys %walletcmds) {
	$cmd = $walletcmds{$key};
	if ($opt_v > 0) {
		print " ".$key.": ".$cmd;
	}
	open(U,"${cmd} listunspent ${opt_C} 2>&1 |");
	my $line;
	my $text = "";
	while(<U>) {
		chomp($line = $_);
		$text .= $line;
	}
	close(U);
	if ($text =~ /^rpcCommand:/) {
		printf "    %s: Error: %s\n", $key, $text;
		next;
	}

	my $parsed;
	eval {
		$parsed = $json->decode( $text );
	};
	if ($@) {
		printf "%s: json->decode('%s') Error: %s\n", $key, $text, $@;
		next;
	}

	#print $json->pretty->encode( $parsed );

	if (ref($parsed) ne "ARRAY") {
		print "Error somewhere, parsed ref = ".ref($parsed)."\n";
		exit(1);
	}

	TX:
	foreach my $tx (@{$parsed}) {
		if (ref($tx) ne "HASH") {
			print "Error somewhere, parsed tx = ".ref($tx)."\n";
			exit(1);
		}
		if ($opt_v > 0) {
			printf "%s: tx#%s %0.8f BTC\n", $key, $tx->{'txid'}, $tx->{'amount'};
		}
		foreach my $txb (@txblacklist) {
			if ($txb eq $tx->{'txid'}) {
				if ($opt_v > 0) {
					printf "%s: tx#%s matched txblacklist, skipping\n",
					    $key, $tx->{'txid'};
				}
				next TX;
			}
		}
		if (defined($opt_m) && $tx->{'amount'} < $opt_m) {
			next TX;
		}
		if (@txaddrs) {
			my $found = 0;
			foreach my $addr (@txaddrs) {
				if ($addr eq $tx->{'address'}) {
					$found = 1;
					last;
				}
				if ($opt_v > 0) {
					printf "%s: %s\@tx#%s != %s, skipping\n",
					    $key, $tx->{'address'}, $tx->{'txid'}, $addr;
				}
			}
			if ($found < 1) {
				next TX;
			}
		}
		$txcount++;
		if ($opt_v > 0) {
			foreach my $var (sort keys %{$tx}) {
				printf "%02d: '%s' = '%s'\n", $txcount, $var, $tx->{$var};
			}
		}
		my $txs;
		$txs->{'txid'} = $tx->{'txid'};
		$txs->{'vout'} = $tx->{'vout'};
		push @txsend,$txs;
		$txvalue += $tx->{'amount'}+0.00000000;
	}
	print $key.": All unspent inputs total: ".$txvalue."\n";
	print $key.": Wallets balance: ".`${cmd} getbalance`."\n";
}

if ($txvalue == 0.0) {
	print "0 BTC to spend, feedme!\n";
	exit(1);
}
if ($txvalue <= $abs) {
	print "Can't overspend BTC, feedme!\n";
	exit(1);
}
$pctstr = sprintf "%0.8f", $pct;
my $onestr = sprintf "%0.8f", 100.0;
if ( !(($txvalue - $opt_t) == $abs) && $pctstr ne $onestr) {
	my $intro;
	if ($abs > 0) {
		$intro = "Absolute spend";
	} else {
		$intro = "Spend";
	}
	printf "%s with leftovers (%0.4f%% - 100%% = %0.4f%%), percent must be 100%% for change!\n",$intro,$pct,100.0-$pct;
	exit(1);
}

#print "Pretty view of transactions to send:\n";
#print $json->pretty->encode( \@txsend );
print "Compact view of transactions to send:\n";
#print $json->encode( \@txsend )."\n";
my $str = "[";
foreach my $tx (@txsend) {
	$str .= "{";
	foreach my $v (sort keys %{$tx}) {
		if ($v eq "txid") {
			$str .= sprintf "\"txid\":\"%s\",",$tx->{$v};
			next;
		}
		$str .= sprintf "\"vout\":%d",$tx->{$v};
	}
	$str .= "},"
}
$str =~ s/,$//;
$str .= "]";
print $str."\n";

my $sendtx = $str;

my $addrs;
my $net = $txvalue - $opt_t;
my $sum = 0.00000000;
my $abssum = 0.00000000;

# handle absolute btc amounts
foreach my $o (@outputs) {
	my ($addr,$pct,$min) = split(/:/,$o);
	my $amt;
	if ($pct =~ /(%|usd)/i) {
		next;
	}
	$amt = $pct;
	$addrs->{$addr} = sprintf "%0.8f",$amt;
	$abssum += $amt;
}

# handle absolute usd amounts converted to btc
foreach my $o (@outputs) {
	my ($addr,$pct,$min) = split(/:/,$o);
	my $usd;
	if (! ($pct =~ /usd/i)) {
		next;
	}
	$usd = $pct;
	$usd =~ s/usd//i;
	my $btc = $usd * (1/$usdperbtc);
	$addrs->{$addr} = sprintf "%0.8f",$btc;
	$abssum += $btc;
}

# handle remainder as percentages (if any)
my $absnet = $net - $abssum;
foreach my $o (@outputs) {
	my ($addr,$pct,$min) = split(/:/,$o);
	my $amt;
	if ($pct =~ /%/) {
		$pct =~ s/%//;

		$amt = $absnet*($pct/100);
		if (defined($min) && $amt < $min) {
			printf "output '%s' has a minimum. ".
			    "%0.8f * %0.4f%% = %0.8f .. is < %0.8f. ".
			    "disabling transmission!\n",
			    $o, $absnet, $pct/100, $amt, $min;
			$opt_n=1;
		}
		$addrs->{$addr} = sprintf "%0.8f",$amt;
		$sum += $amt;
	}
}

print "Compact view of dest addrs:\n";
#print $json->encode( $addrs )."\n";
$str = "{";
foreach my $v (sort keys %{$addrs}) {
	$str .= sprintf "\"%s\":%0.8f,",$v,$addrs->{$v};
}
$str =~ s/,$//;
$str .= "}";
print $str."\n";

my $sendaddrs = $str;

printf "Tx Fee: %0.8f\n",$txvalue-$sum-$abssum;

my $rawtxhex;
open(C,"${cmd} createrawtransaction '${sendtx}' '${sendaddrs}'|");
my $tmp = <C>;
close(C);
if (!defined($tmp)) {
	print "rawtxhex !defined, bailing\n";
	exit(1);
}
chomp($rawtxhex = $tmp);

my $lasthex = $rawtxhex;
my $line;
my $signedhex;
foreach my $key (keys %walletcmds) {
	$cmd = $walletcmds{$key};
	my $signedtx = "";
	open(S,"${cmd} signrawtransaction ${lasthex} 2>&1 |");
	while(<S>) {
		chomp($line = $_);
		$signedtx .= $line;
	#	print "S: ".$line."\n";
	}
	close(S);
	if ($signedtx =~ /^rpcCommand/) {
		printf "%s: signrawtransaction Error: %s\n", $key, $signedtx;
		decoderaw($cmd, $lasthex);
		next;
	}
	my $parsedsignedtx;
	eval {
		if ($opt_v > 0) {
			printf "json->decode('%s')...\n",$signedtx;
		}
		$parsedsignedtx = $json->decode( $signedtx );
	};
	if ($@) {
		printf "json->decode('%s') failed: %s\n",$signedtx,$@;
		decoderaw($cmd, $signedtx);
	} else {
		$signedhex = $parsedsignedtx->{'hex'};
		$lasthex = $signedhex;
	}

}

open(SEND,">>","sendtx.log");
print SEND "${cmd} sendrawtransaction ${signedhex}\n";
close(SEND);

if (!defined($opt_n)) {
	my $line;
	my $text = "";
	open(C,"${cmd} sendrawtransaction ${signedhex} 2>&1 |");
	while(<C>) {
		chomp($line = $_);
		$text .= $line;
	}
	close(C);
	if ($text =~ /^rpcCommand/) {
		printf "signrawtransaction Error: %s\n", $text;
		decoderaw($cmd, $signedhex);
		exit(1);
	}
	system("./pushtx ${signedhex}");
}

decoderaw($cmd,$signedhex);
close(D);

sub decoderaw {
	my ($cmd, $rawtx) = @_;
	open(D,"${cmd} decoderawtransaction ${rawtx}|");
	while(<D>) {
		print "D: ".$_;
	}
}
